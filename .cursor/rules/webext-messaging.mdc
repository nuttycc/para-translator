---
description: @webext-core/messaging a simplified, type-safe wrapper around the web extension messaging APIs.
alwaysApply: false
---

{
  "results": [
    {
      "url": "https://webext-core.aklinker1.io/messaging/protocol-maps",
      "raw_content": "# [Protocol Maps](/messaging/protocol-maps#protocol-maps)\n\n## [Overview](/messaging/protocol-maps#overview)\n\nProtocol maps define types for `sendMessage` and `onMessage` in a single place. You'll never need to write type parameters; the data and return types will be inferred automatically!\n\n`sendMessage`\n`onMessage`\n\n## [Syntax](/messaging/protocol-maps#syntax)\n\nProtocol maps are simple interfaces passed into `defineExtensionMessaging`. They specify a list of valid message types, as well as each message's data type and return type.\n\n`defineExtensionMessaging`\n`interface ProtocolMap {\n message1(): void; // No data and no return type\n message2(data: string): void; // Only data\n message3(): boolean; // Only a return type\n message4(data: string): boolean; // Data and return type\n}\nexport const { sendMessage, onMessage } = defineExtensionMessaging<ProtocolMap>();`\n\nWhen calling `sendMessage` or `onMessage`, all the types will be inferred:\n\n`sendMessage`\n`onMessage`\n`onMessage('message2', ({ data /* string */ }) /* : void */ => {});\nonMessage('message3', (message) /* : boolean */ => true);\nconst res /* : boolean */ = await sendMessage('message3', undefined);\nconst res /* : boolean */ = await sendMessage('message4', 'text');`\n\n## [Async Messages](/messaging/protocol-maps#async-messages)\n\nAll messages are async. In your protocol map, you don't need to make the return type `Promise<T>`, `T` will work just fine.\n\n`Promise<T>`\n`T`\n`interface ProtocolMap {\n someMessage(): string;  someMessage(): Promise<string>; }`\n\n## [Multiple Arguments](/messaging/protocol-maps#multiple-arguments)\n\nProtocol map functions should be defined with a single parameter, `data`. To pass more than one argument, make the `data` parameter an object instead!\n\n`data`\n`data`\n`interface ProtocolMap {\n someMessage(data: { arg1: string; arg2: boolean }): void;  someMessage(arg1: string, arg2: boolean): void; }`\n`await sendMessage('someMessage', { arg1: ..., arg2: ... });`\n\nPowered by Docus",
      "images": []
    }
  ],
  "failed_results": [],
  "response_time": 0.22,
  "request_id": "04a3a571-b5e2-4abd-9c08-1d4339218113"
}

{
  "results": [
    {
      "url": "https://webext-core.aklinker1.io/messaging/api",
      "raw_content": "# [API Reference](/messaging/api#api-reference)\n\n`@webext-core/messaging`\n\n## [`BaseMessagingConfig`](/messaging/api#basemessagingconfig)\n\n`BaseMessagingConfig`\n`interface BaseMessagingConfig {\n logger?: Logger;\n breakError?: boolean;\n}`\n\nShared configuration between all the different messengers.\n\n### [Properties](/messaging/api#properties)\n\n`logger?: Logger`\n`console`\n`null`\n`breakError?: boolean`\n`undefined`\n\n## [`CustomEventMessage`](/messaging/api#customeventmessage)\n\n`CustomEventMessage`\n`interface CustomEventMessage {\n event: CustomEvent;\n}`\n\nAdditional fields available on the `Message` from a `CustomEventMessenger`.\n\n`Message`\n`CustomEventMessenger`\n\n### [Properties](/messaging/api#properties-1)\n\n`event: CustomEvent`\n\n## [`CustomEventMessagingConfig`](/messaging/api#customeventmessagingconfig)\n\n`CustomEventMessagingConfig`\n`interface CustomEventMessagingConfig extends NamespaceMessagingConfig {}`\n\nConfiguration passed into `defineCustomEventMessaging`.\n\n`defineCustomEventMessaging`\n\n## [`CustomEventMessenger`](/messaging/api#customeventmessenger)\n\n`CustomEventMessenger`\n`type CustomEventMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, CustomEventMessage, []>;`\n\nMessenger returned by `defineCustomEventMessenger`.\n\n`defineCustomEventMessenger`\n\n## [`defineCustomEventMessaging`](/messaging/api#definecustomeventmessaging)\n\n`defineCustomEventMessaging`\n`function defineCustomEventMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config: CustomEventMessagingConfig): CustomEventMessenger<TProtocolMap> {\n // ...\n}`\n\nCreates a `CustomEventMessenger`. This messenger is backed by the `CustomEvent` APIs. It can be\nused to communicate between:\n\n`CustomEventMessenger`\n`CustomEvent`\n\n`sendMessage` does not accept any additional arguments..\n\n`sendMessage`\n\n### [Examples](/messaging/api#examples)\n\n`interface WebsiteMessengerSchema {\n initInjectedScript(data: ...): void;\n}\nexport const websiteMessenger = defineCustomEventMessenger<initInjectedScript>();\n// Content script\nwebsiteMessenger.sendMessage(\"initInjectedScript\", ...);\n// Injected script\nwebsiteMessenger.onMessage(\"initInjectedScript\", (...) => {\n // ...\n})\n*`\n\n## [`defineExtensionMessaging`](/messaging/api#defineextensionmessaging)\n\n`defineExtensionMessaging`\n`function defineExtensionMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config?: ExtensionMessagingConfig): ExtensionMessenger<TProtocolMap> {\n // ...\n}`\n\nReturns an `ExtensionMessenger` that is backed by the `browser.runtime.sendMessage` and\n`browser.tabs.sendMessage` APIs.\n\n`ExtensionMessenger`\n`browser.runtime.sendMessage`\n`browser.tabs.sendMessage`\n\nIt can be used to send messages to and from the background page/service worker.\n\n## [`defineWindowMessaging`](/messaging/api#definewindowmessaging)\n\n`defineWindowMessaging`\n`function defineWindowMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config: WindowMessagingConfig): WindowMessenger<TProtocolMap> {\n // ...\n}`\n\nReturns a `WindowMessenger`. It is backed by the `window.postMessage` API. It can be used to\ncommunicate between:\n\n`WindowMessenger`\n`window.postMessage`\n\n### [Examples](/messaging/api#examples-1)\n\n`interface WebsiteMessengerSchema {\n initInjectedScript(data: ...): void;\n}\nexport const websiteMessenger = defineWindowMessaging<initInjectedScript>();\n// Content script\nwebsiteMessenger.sendMessage(\"initInjectedScript\", ...);\n// Injected script\nwebsiteMessenger.onMessage(\"initInjectedScript\", (...) => {\n // ...\n})`\n\n## [`ExtensionMessage`](/messaging/api#extensionmessage)\n\n`ExtensionMessage`\n`interface ExtensionMessage {\n sender: Runtime.MessageSender;\n}`\n\nAdditional fields available on the `Message` from an `ExtensionMessenger`.\n\n`Message`\n`ExtensionMessenger`\n\n### [Properties](/messaging/api#properties-2)\n\n`sender: Runtime.MessageSender`\n`Runtime.MessageSender`\n\n## [`ExtensionMessagingConfig`](/messaging/api#extensionmessagingconfig)\n\n`ExtensionMessagingConfig`\n`interface ExtensionMessagingConfig extends BaseMessagingConfig {}`\n\nConfiguration passed into `defineExtensionMessaging`.\n\n`defineExtensionMessaging`\n\n## [`ExtensionMessenger`](/messaging/api#extensionmessenger)\n\n`ExtensionMessenger`\n`type ExtensionMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, ExtensionMessage, ExtensionSendMessageArgs>;`\n\nMessenger returned by `defineExtensionMessaging`.\n\n`defineExtensionMessaging`\n\n## [`ExtensionSendMessageArgs`](/messaging/api#extensionsendmessageargs)\n\n`ExtensionSendMessageArgs`\n`type ExtensionSendMessageArgs = [arg?: number | SendMessageOptions];`\n\nSend message accepts either:\n\nYou cannot message between tabs directly. It must go through the background script.\n\n## [`GenericMessenger`](/messaging/api#genericmessenger)\n\n`GenericMessenger`\n`interface GenericMessenger<\n TProtocolMap extends Record<string, any>,\n TMessageExtension,\n TSendMessageArgs extends any[],\n> {\n sendMessage<TType extends keyof TProtocolMap>(\n type: TType,\n ...args: GetDataType<TProtocolMap[TType]> extends undefined\n ? [data?: undefined, ...args: TSendMessageArgs]\n : never\n ): Promise<GetReturnType<TProtocolMap[TType]>>;\n sendMessage<TType extends keyof TProtocolMap>(\n type: TType,\n data: GetDataType<TProtocolMap[TType]>,\n ...args: TSendMessageArgs\n ): Promise<GetReturnType<TProtocolMap[TType]>>;\n onMessage<TType extends keyof TProtocolMap>(\n type: TType,\n onReceived: (\n message: Message<TProtocolMap, TType> & TMessageExtension,\n ) => void | MaybePromise<GetReturnType<TProtocolMap[TType]>>,\n ): RemoveListenerCallback;\n removeAllListeners(): void;\n}`\n\nMessaging interface shared by all messengers.\n\nType parameters accept:\n\n`TProtocolMap`\n`TMessageExtension`\n`onMessage`\n`TSendMessageArgs`\n`sendMessage`\n\n## [`GetDataType`](/messaging/api#getdatatype)\n\n`GetDataType`\n`type GetDataType<T> = T extends (...args: infer Args) => any\n ? Args[\"length\"] extends 0 | 1\n ? Args[0]\n : never\n : T extends ProtocolWithReturn<any, any>\n ? T[\"BtVgCTPYZu\"]\n : T;`\n\nGiven a function declaration, `ProtocolWithReturn`, or a value, return the message's data type.\n\n`ProtocolWithReturn`\n\n## [`GetReturnType`](/messaging/api#getreturntype)\n\n`GetReturnType`\n`type GetReturnType<T> = T extends (...args: any[]) => infer R\n ? R\n : T extends ProtocolWithReturn<any, any>\n ? T[\"RrhVseLgZW\"]\n : void;`\n\nGiven a function declaration, `ProtocolWithReturn`, or a value, return the message's return type.\n\n`ProtocolWithReturn`\n\n## [`Logger`](/messaging/api#logger)\n\n`Logger`\n`interface Logger {\n debug(...args: any[]): void;\n log(...args: any[]): void;\n warn(...args: any[]): void;\n error(...args: any[]): void;\n}`\n\nInterface used to log text to the console when sending and receiving messages.\n\n## [`MaybePromise`](/messaging/api#maybepromise)\n\n`MaybePromise`\n`type MaybePromise<T> = Promise<T> | T;`\n\nEither a Promise of a type, or that type directly. Used to indicate that a method can by sync or\nasync.\n\n## [`Message`](/messaging/api#message)\n\n`Message`\n`interface Message<\n TProtocolMap extends Record<string, any>,\n TType extends keyof TProtocolMap,\n> {\n id: number;\n data: GetDataType<TProtocolMap[TType]>;\n type: TType;\n timestamp: number;\n}`\n\nContains information about the message received.\n\n### [Properties](/messaging/api#properties-3)\n\n`id: number`\n`data: GetDataType<TProtocolMap[TType]>`\n`sendMessage`\n`type: TType`\n`timestamp: number`\n\n## [`MessageSender`](/messaging/api#messagesender)\n\n`MessageSender`\n`interface MessageSender {\n tab?: Tabs.Tab;\n frameId?: number;\n id?: string;\n url?: string;\n}`\n\nAn object containing information about the script context that sent a message or request.\n\n### [Properties](/messaging/api#properties-4)\n\n`tab?: Tabs.Tab`\n`frameId?: number`\n`tab`\n`id?: string`\n`url?: string`\n\n## [`NamespaceMessagingConfig`](/messaging/api#namespacemessagingconfig)\n\n`NamespaceMessagingConfig`\n`interface NamespaceMessagingConfig extends BaseMessagingConfig {\n namespace: string;\n}`\n\n### [Properties](/messaging/api#properties-5)\n\n`namespace: string`\n\n## [`ProtocolWithReturn`](/messaging/api#protocolwithreturn)\n\n`ProtocolWithReturn`\n\n:::danger Deprecated\nUse the function syntax instead: <https://webext-core.aklinker1.io/guide/messaging/protocol-maps.html#syntax>\n:::\n\n`interface ProtocolWithReturn<TData, TReturn> {\n BtVgCTPYZu: TData;\n RrhVseLgZW: TReturn;\n}`\n\nUsed to add a return type to a message in the protocol map.\n\nInternally, this is just an object with random keys for the data and return types.\n\n### [Properties](/messaging/api#properties-6)\n\n`BtVgCTPYZu: TData`\n`RrhVseLgZW: TReturn`\n\n### [Examples](/messaging/api#examples-2)\n\n`interface ProtocolMap {\n // data is a string, returns undefined\n type1: string;\n // data is a string, returns a number\n type2: ProtocolWithReturn<string, number>;\n}`\n\n## [`RemoveListenerCallback`](/messaging/api#removelistenercallback)\n\n`RemoveListenerCallback`\n`type RemoveListenerCallback = () => void;`\n\nCall to ensure an active listener has been removed.\n\nIf the listener has already been removed with `Messenger.removeAllListeners`, this is a noop.\n\n`Messenger.removeAllListeners`\n\n## [`SendMessageOptions`](/messaging/api#sendmessageoptions)\n\n`SendMessageOptions`\n`interface SendMessageOptions {\n tabId: number;\n frameId?: number;\n}`\n\nOptions for sending a message to a specific tab/frame\n\n### [Properties](/messaging/api#properties-7)\n\n`tabId: number`\n`frameId?: number`\n\n## [`WindowMessagingConfig`](/messaging/api#windowmessagingconfig)\n\n`WindowMessagingConfig`\n`interface WindowMessagingConfig extends NamespaceMessagingConfig {}`\n\nConfiguration passed into `defineWindowMessaging`.\n\n`defineWindowMessaging`\n\n## [`WindowMessenger`](/messaging/api#windowmessenger)\n\n`WindowMessenger`\n`type WindowMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, {}, WindowSendMessageArgs>;`\n\n## [`WindowSendMessageArgs`](/messaging/api#windowsendmessageargs)\n\n`WindowSendMessageArgs`\n`type WindowSendMessageArgs = [targetOrigin?: string];`\n\nFor a `WindowMessenger`, `sendMessage` requires an additional argument, the `targetOrigin`. It\ndefines which frames inside the page should receive the message.\n\n`WindowMessenger`\n`sendMessage`\n`targetOrigin`\n\nSee <https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#targetorigin> for more\ndetails.\n\n*API reference generated by [`docs/generate-api-references.ts`](https://github.com/aklinker1/webext-core/blob/main/docs/generate-api-references.ts)*\n\n`docs/generate-api-references.ts`\n\nPowered by Docus",
      "images": []
    }
  ],
  "failed_results": [],
  "response_time": 1.04,
  "request_id": "2a0cf807-c257-4d82-8461-f694ee1d0ba0"
}

{
  "results": [
    {
      "url": "https://webext-core.aklinker1.io/messaging/protocol-maps",
      "raw_content": "# [Protocol Maps](/messaging/protocol-maps#protocol-maps)\n\n## [Overview](/messaging/protocol-maps#overview)\n\nProtocol maps define types for `sendMessage` and `onMessage` in a single place. You'll never need to write type parameters; the data and return types will be inferred automatically!\n\n`sendMessage`\n`onMessage`\n\n## [Syntax](/messaging/protocol-maps#syntax)\n\nProtocol maps are simple interfaces passed into `defineExtensionMessaging`. They specify a list of valid message types, as well as each message's data type and return type.\n\n`defineExtensionMessaging`\n`interface ProtocolMap {\n message1(): void; // No data and no return type\n message2(data: string): void; // Only data\n message3(): boolean; // Only a return type\n message4(data: string): boolean; // Data and return type\n}\nexport const { sendMessage, onMessage } = defineExtensionMessaging<ProtocolMap>();`\n\nWhen calling `sendMessage` or `onMessage`, all the types will be inferred:\n\n`sendMessage`\n`onMessage`\n`onMessage('message2', ({ data /* string */ }) /* : void */ => {});\nonMessage('message3', (message) /* : boolean */ => true);\nconst res /* : boolean */ = await sendMessage('message3', undefined);\nconst res /* : boolean */ = await sendMessage('message4', 'text');`\n\n## [Async Messages](/messaging/protocol-maps#async-messages)\n\nAll messages are async. In your protocol map, you don't need to make the return type `Promise<T>`, `T` will work just fine.\n\n`Promise<T>`\n`T`\n`interface ProtocolMap {\n someMessage(): string;  someMessage(): Promise<string>; }`\n\n## [Multiple Arguments](/messaging/protocol-maps#multiple-arguments)\n\nProtocol map functions should be defined with a single parameter, `data`. To pass more than one argument, make the `data` parameter an object instead!\n\n`data`\n`data`\n`interface ProtocolMap {\n someMessage(data: { arg1: string; arg2: boolean }): void;  someMessage(arg1: string, arg2: boolean): void; }`\n`await sendMessage('someMessage', { arg1: ..., arg2: ... });`\n\nPowered by Docus",
      "images": []
    }
  ],
  "failed_results": [],
  "response_time": 0.22,
  "request_id": "04a3a571-b5e2-4abd-9c08-1d4339218113"
}

{
  "results": [
    {
      "url": "https://webext-core.aklinker1.io/messaging/api",
      "raw_content": "# [API Reference](/messaging/api#api-reference)\n\n`@webext-core/messaging`\n\n## [`BaseMessagingConfig`](/messaging/api#basemessagingconfig)\n\n`BaseMessagingConfig`\n`interface BaseMessagingConfig {\n logger?: Logger;\n breakError?: boolean;\n}`\n\nShared configuration between all the different messengers.\n\n### [Properties](/messaging/api#properties)\n\n`logger?: Logger`\n`console`\n`null`\n`breakError?: boolean`\n`undefined`\n\n## [`CustomEventMessage`](/messaging/api#customeventmessage)\n\n`CustomEventMessage`\n`interface CustomEventMessage {\n event: CustomEvent;\n}`\n\nAdditional fields available on the `Message` from a `CustomEventMessenger`.\n\n`Message`\n`CustomEventMessenger`\n\n### [Properties](/messaging/api#properties-1)\n\n`event: CustomEvent`\n\n## [`CustomEventMessagingConfig`](/messaging/api#customeventmessagingconfig)\n\n`CustomEventMessagingConfig`\n`interface CustomEventMessagingConfig extends NamespaceMessagingConfig {}`\n\nConfiguration passed into `defineCustomEventMessaging`.\n\n`defineCustomEventMessaging`\n\n## [`CustomEventMessenger`](/messaging/api#customeventmessenger)\n\n`CustomEventMessenger`\n`type CustomEventMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, CustomEventMessage, []>;`\n\nMessenger returned by `defineCustomEventMessenger`.\n\n`defineCustomEventMessenger`\n\n## [`defineCustomEventMessaging`](/messaging/api#definecustomeventmessaging)\n\n`defineCustomEventMessaging`\n`function defineCustomEventMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config: CustomEventMessagingConfig): CustomEventMessenger<TProtocolMap> {\n // ...\n}`\n\nCreates a `CustomEventMessenger`. This messenger is backed by the `CustomEvent` APIs. It can be\nused to communicate between:\n\n`CustomEventMessenger`\n`CustomEvent`\n\n`sendMessage` does not accept any additional arguments..\n\n`sendMessage`\n\n### [Examples](/messaging/api#examples)\n\n`interface WebsiteMessengerSchema {\n initInjectedScript(data: ...): void;\n}\nexport const websiteMessenger = defineCustomEventMessenger<initInjectedScript>();\n// Content script\nwebsiteMessenger.sendMessage(\"initInjectedScript\", ...);\n// Injected script\nwebsiteMessenger.onMessage(\"initInjectedScript\", (...) => {\n // ...\n})\n*`\n\n## [`defineExtensionMessaging`](/messaging/api#defineextensionmessaging)\n\n`defineExtensionMessaging`\n`function defineExtensionMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config?: ExtensionMessagingConfig): ExtensionMessenger<TProtocolMap> {\n // ...\n}`\n\nReturns an `ExtensionMessenger` that is backed by the `browser.runtime.sendMessage` and\n`browser.tabs.sendMessage` APIs.\n\n`ExtensionMessenger`\n`browser.runtime.sendMessage`\n`browser.tabs.sendMessage`\n\nIt can be used to send messages to and from the background page/service worker.\n\n## [`defineWindowMessaging`](/messaging/api#definewindowmessaging)\n\n`defineWindowMessaging`\n`function defineWindowMessaging<\n TProtocolMap extends Record<string, any> = Record<string, any>,\n>(config: WindowMessagingConfig): WindowMessenger<TProtocolMap> {\n // ...\n}`\n\nReturns a `WindowMessenger`. It is backed by the `window.postMessage` API. It can be used to\ncommunicate between:\n\n`WindowMessenger`\n`window.postMessage`\n\n### [Examples](/messaging/api#examples-1)\n\n`interface WebsiteMessengerSchema {\n initInjectedScript(data: ...): void;\n}\nexport const websiteMessenger = defineWindowMessaging<initInjectedScript>();\n// Content script\nwebsiteMessenger.sendMessage(\"initInjectedScript\", ...);\n// Injected script\nwebsiteMessenger.onMessage(\"initInjectedScript\", (...) => {\n // ...\n})`\n\n## [`ExtensionMessage`](/messaging/api#extensionmessage)\n\n`ExtensionMessage`\n`interface ExtensionMessage {\n sender: Runtime.MessageSender;\n}`\n\nAdditional fields available on the `Message` from an `ExtensionMessenger`.\n\n`Message`\n`ExtensionMessenger`\n\n### [Properties](/messaging/api#properties-2)\n\n`sender: Runtime.MessageSender`\n`Runtime.MessageSender`\n\n## [`ExtensionMessagingConfig`](/messaging/api#extensionmessagingconfig)\n\n`ExtensionMessagingConfig`\n`interface ExtensionMessagingConfig extends BaseMessagingConfig {}`\n\nConfiguration passed into `defineExtensionMessaging`.\n\n`defineExtensionMessaging`\n\n## [`ExtensionMessenger`](/messaging/api#extensionmessenger)\n\n`ExtensionMessenger`\n`type ExtensionMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, ExtensionMessage, ExtensionSendMessageArgs>;`\n\nMessenger returned by `defineExtensionMessaging`.\n\n`defineExtensionMessaging`\n\n## [`ExtensionSendMessageArgs`](/messaging/api#extensionsendmessageargs)\n\n`ExtensionSendMessageArgs`\n`type ExtensionSendMessageArgs = [arg?: number | SendMessageOptions];`\n\nSend message accepts either:\n\nYou cannot message between tabs directly. It must go through the background script.\n\n## [`GenericMessenger`](/messaging/api#genericmessenger)\n\n`GenericMessenger`\n`interface GenericMessenger<\n TProtocolMap extends Record<string, any>,\n TMessageExtension,\n TSendMessageArgs extends any[],\n> {\n sendMessage<TType extends keyof TProtocolMap>(\n type: TType,\n ...args: GetDataType<TProtocolMap[TType]> extends undefined\n ? [data?: undefined, ...args: TSendMessageArgs]\n : never\n ): Promise<GetReturnType<TProtocolMap[TType]>>;\n sendMessage<TType extends keyof TProtocolMap>(\n type: TType,\n data: GetDataType<TProtocolMap[TType]>,\n ...args: TSendMessageArgs\n ): Promise<GetReturnType<TProtocolMap[TType]>>;\n onMessage<TType extends keyof TProtocolMap>(\n type: TType,\n onReceived: (\n message: Message<TProtocolMap, TType> & TMessageExtension,\n ) => void | MaybePromise<GetReturnType<TProtocolMap[TType]>>,\n ): RemoveListenerCallback;\n removeAllListeners(): void;\n}`\n\nMessaging interface shared by all messengers.\n\nType parameters accept:\n\n`TProtocolMap`\n`TMessageExtension`\n`onMessage`\n`TSendMessageArgs`\n`sendMessage`\n\n## [`GetDataType`](/messaging/api#getdatatype)\n\n`GetDataType`\n`type GetDataType<T> = T extends (...args: infer Args) => any\n ? Args[\"length\"] extends 0 | 1\n ? Args[0]\n : never\n : T extends ProtocolWithReturn<any, any>\n ? T[\"BtVgCTPYZu\"]\n : T;`\n\nGiven a function declaration, `ProtocolWithReturn`, or a value, return the message's data type.\n\n`ProtocolWithReturn`\n\n## [`GetReturnType`](/messaging/api#getreturntype)\n\n`GetReturnType`\n`type GetReturnType<T> = T extends (...args: any[]) => infer R\n ? R\n : T extends ProtocolWithReturn<any, any>\n ? T[\"RrhVseLgZW\"]\n : void;`\n\nGiven a function declaration, `ProtocolWithReturn`, or a value, return the message's return type.\n\n`ProtocolWithReturn`\n\n## [`Logger`](/messaging/api#logger)\n\n`Logger`\n`interface Logger {\n debug(...args: any[]): void;\n log(...args: any[]): void;\n warn(...args: any[]): void;\n error(...args: any[]): void;\n}`\n\nInterface used to log text to the console when sending and receiving messages.\n\n## [`MaybePromise`](/messaging/api#maybepromise)\n\n`MaybePromise`\n`type MaybePromise<T> = Promise<T> | T;`\n\nEither a Promise of a type, or that type directly. Used to indicate that a method can by sync or\nasync.\n\n## [`Message`](/messaging/api#message)\n\n`Message`\n`interface Message<\n TProtocolMap extends Record<string, any>,\n TType extends keyof TProtocolMap,\n> {\n id: number;\n data: GetDataType<TProtocolMap[TType]>;\n type: TType;\n timestamp: number;\n}`\n\nContains information about the message received.\n\n### [Properties](/messaging/api#properties-3)\n\n`id: number`\n`data: GetDataType<TProtocolMap[TType]>`\n`sendMessage`\n`type: TType`\n`timestamp: number`\n\n## [`MessageSender`](/messaging/api#messagesender)\n\n`MessageSender`\n`interface MessageSender {\n tab?: Tabs.Tab;\n frameId?: number;\n id?: string;\n url?: string;\n}`\n\nAn object containing information about the script context that sent a message or request.\n\n### [Properties](/messaging/api#properties-4)\n\n`tab?: Tabs.Tab`\n`frameId?: number`\n`tab`\n`id?: string`\n`url?: string`\n\n## [`NamespaceMessagingConfig`](/messaging/api#namespacemessagingconfig)\n\n`NamespaceMessagingConfig`\n`interface NamespaceMessagingConfig extends BaseMessagingConfig {\n namespace: string;\n}`\n\n### [Properties](/messaging/api#properties-5)\n\n`namespace: string`\n\n## [`ProtocolWithReturn`](/messaging/api#protocolwithreturn)\n\n`ProtocolWithReturn`\n\n:::danger Deprecated\nUse the function syntax instead: <https://webext-core.aklinker1.io/guide/messaging/protocol-maps.html#syntax>\n:::\n\n`interface ProtocolWithReturn<TData, TReturn> {\n BtVgCTPYZu: TData;\n RrhVseLgZW: TReturn;\n}`\n\nUsed to add a return type to a message in the protocol map.\n\nInternally, this is just an object with random keys for the data and return types.\n\n### [Properties](/messaging/api#properties-6)\n\n`BtVgCTPYZu: TData`\n`RrhVseLgZW: TReturn`\n\n### [Examples](/messaging/api#examples-2)\n\n`interface ProtocolMap {\n // data is a string, returns undefined\n type1: string;\n // data is a string, returns a number\n type2: ProtocolWithReturn<string, number>;\n}`\n\n## [`RemoveListenerCallback`](/messaging/api#removelistenercallback)\n\n`RemoveListenerCallback`\n`type RemoveListenerCallback = () => void;`\n\nCall to ensure an active listener has been removed.\n\nIf the listener has already been removed with `Messenger.removeAllListeners`, this is a noop.\n\n`Messenger.removeAllListeners`\n\n## [`SendMessageOptions`](/messaging/api#sendmessageoptions)\n\n`SendMessageOptions`\n`interface SendMessageOptions {\n tabId: number;\n frameId?: number;\n}`\n\nOptions for sending a message to a specific tab/frame\n\n### [Properties](/messaging/api#properties-7)\n\n`tabId: number`\n`frameId?: number`\n\n## [`WindowMessagingConfig`](/messaging/api#windowmessagingconfig)\n\n`WindowMessagingConfig`\n`interface WindowMessagingConfig extends NamespaceMessagingConfig {}`\n\nConfiguration passed into `defineWindowMessaging`.\n\n`defineWindowMessaging`\n\n## [`WindowMessenger`](/messaging/api#windowmessenger)\n\n`WindowMessenger`\n`type WindowMessenger<TProtocolMap extends Record<string, any>> =\n GenericMessenger<TProtocolMap, {}, WindowSendMessageArgs>;`\n\n## [`WindowSendMessageArgs`](/messaging/api#windowsendmessageargs)\n\n`WindowSendMessageArgs`\n`type WindowSendMessageArgs = [targetOrigin?: string];`\n\nFor a `WindowMessenger`, `sendMessage` requires an additional argument, the `targetOrigin`. It\ndefines which frames inside the page should receive the message.\n\n`WindowMessenger`\n`sendMessage`\n`targetOrigin`\n\nSee <https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#targetorigin> for more\ndetails.\n\n*API reference generated by [`docs/generate-api-references.ts`](https://github.com/aklinker1/webext-core/blob/main/docs/generate-api-references.ts)*\n\n`docs/generate-api-references.ts`\n\nPowered by Docus",
      "images": []
    }
  ],
  "failed_results": [],
  "response_time": 1.04,
  "request_id": "2a0cf807-c257-4d82-8461-f694ee1d0ba0"
}
