This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/agent/agent.ts
src/agent/executor/base.ts
src/agent/executor/explain.ts
src/agent/executor/translate.ts
src/agent/seeds.ts
src/agent/storage.ts
src/agent/types.ts
src/assets/base.css
src/assets/content-ui.css
src/assets/vue.svg
src/components/AiConfig.vue
src/components/HelloWorld.vue
src/components/ParaCard.vue
src/components/PromptEditor.vue
src/components/TaskConfig.vue
src/entrypoints/background.ts
src/entrypoints/content/cache-manager.ts
src/entrypoints/content/card-manager.ts
src/entrypoints/content/content-utils.ts
src/entrypoints/content/event-handler.ts
src/entrypoints/content/index.ts
src/entrypoints/content/ui-manager.ts
src/entrypoints/options/App.vue
src/entrypoints/options/index.html
src/entrypoints/options/main.ts
src/entrypoints/options/router.ts
src/entrypoints/options/views/AiPanel.vue
src/entrypoints/options/views/AiView.vue
src/entrypoints/options/views/HistoryView.vue
src/entrypoints/options/views/TaskPanel.vue
src/entrypoints/options/views/TaskView.vue
src/entrypoints/popup/App.vue
src/entrypoints/popup/index.html
src/entrypoints/popup/main.ts
src/entrypoints/popup/style.css
src/messaging/handlers.ts
src/messaging/index.ts
src/messaging/protocol.ts
src/stores/aiConfigs.ts
src/stores/taskConfigs.ts
src/utils/__tests__/template.test.ts
src/utils/logger.ts
src/utils/paragraph.ts
src/utils/template.ts
src/utils/toast.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/agent/agent.ts">
import { ExplainExecutor } from '@/agent/executor/explain';
import { TranslateExecutor } from '@/agent/executor/translate';
import { agentStorage } from '@/agent/storage';
import {
  TASK_TYPES,
  type AgentContext,
  type AgentResponse,
  type LangAgentSpec,
  type TaskType,
} from '@/agent/types';
import { createLogger } from '@/utils/logger';
⋮----
/**
 * The LangAgent class is a singleton that manages the task executors for the LangAgent.
 * It is responsible for initializing the task executors and performing tasks.
 */
export class LangAgent implements LangAgentSpec
⋮----
async init()
⋮----
async perform(taskType: TaskType, context: AgentContext): Promise<AgentResponse>
⋮----
/**
 * Returns the singleton LangAgent, initializing it on first invocation.
 *
 * If no instance exists, a new LangAgent is created and its async init() is awaited before returning.
 * Note: concurrent callers that run after the instance is created but before init() completes may receive
 * the same LangAgent reference while initialization is still in progress.
 *
 * @returns The initialized (or initializing) singleton LangAgent instance.
 */
export async function getLangAgent(): Promise<LangAgent>
</file>

<file path="src/agent/executor/base.ts">
import { OpenAI } from 'openai';
import type { ChatCompletionCreateParamsNonStreaming } from 'openai/resources/index.mjs';
⋮----
import type { AgentContext, TaskExecutor, TaskRuntimeConfig, TaskType } from '@/agent/types';
import { createLogger } from '@/utils/logger';
import { renderTemplate as renderTpl } from '@/utils/template';
⋮----
export abstract class BaseTaskExecutor implements TaskExecutor
⋮----
abstract execute(context: AgentContext): Promise<string>;
⋮----
// Common OpenAI executor base class to eliminate code duplication
export abstract class OpenAIBaseExecutor extends BaseTaskExecutor
⋮----
abstract init(): Promise<void>;
⋮----
abstract createOpenAIClient(configId: string): Promise<void>;
⋮----
protected async executeBase(
    context: AgentContext,
    useJsonSchema = false,
    responseSchema?: Record<string, unknown>
): Promise<string>
⋮----
// Render prompts in a single pass with safe replacements
⋮----
protected renderTemplate(template: string, context: AgentContext): string
</file>

<file path="src/agent/executor/explain.ts">
import { OpenAI } from 'openai';
import { z } from 'zod';
⋮----
import { OpenAIBaseExecutor } from '@/agent/executor/base';
import { AGENT_SEEDS } from '@/agent/seeds';
import { agentStorage } from '@/agent/storage';
import type { AgentContext, AIConfigs, TaskRuntimeConfigs } from '@/agent/types';
⋮----
export type ResponseFormatType = z.infer<typeof ResponseFormat>;
⋮----
export class ExplainExecutor extends OpenAIBaseExecutor
⋮----
async init()
⋮----
// register watcher after client is ready (see next comment)
⋮----
// Ensure watchers are cleaned up
dispose()
⋮----
async createOpenAIClient(configId: string)
⋮----
async execute(context: AgentContext): Promise<string>
</file>

<file path="src/agent/executor/translate.ts">
import { OpenAI } from 'openai';
⋮----
import { OpenAIBaseExecutor } from '@/agent/executor/base';
import { AGENT_SEEDS } from '@/agent/seeds';
import { agentStorage } from '@/agent/storage';
import type { AgentContext, AIConfigs, TaskRuntimeConfigs } from '@/agent/types';
⋮----
export class TranslateExecutor extends OpenAIBaseExecutor
⋮----
async init()
⋮----
// register watcher after client is ready (see next comment)
⋮----
// Ensure watchers are cleaned up
dispose()
⋮----
async createOpenAIClient(configId: string)
⋮----
async execute(context: AgentContext): Promise<string>
</file>

<file path="src/agent/seeds.ts">
import { type AgentContext, type AIConfigs, type TaskRuntimeConfigs } from '@/agent/types';
</file>

<file path="src/agent/storage.ts">
import { storage } from '#imports';
⋮----
import { AGENT_SEEDS } from '@/agent/seeds';
import { type AgentExecutionResults, type AIConfigs, type TaskRuntimeConfigs } from '@/agent/types';
⋮----
/**
 * AI configurations storage item
 * Stores the list of AI service configurations
 */
⋮----
/**
 * Task runtime configurations storage item
 * Stores runtime configurations for different task types (translate, explain, etc.)
 */
⋮----
/**
 * Agent execution results storage item
 * Stores the list of agent execution results
 */
⋮----
// export all storage items
</file>

<file path="src/agent/types.ts">
// Types are now self-contained to avoid circular dependencies
import { z } from 'zod';
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 📝 TASK TYPES & CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export type TaskType = (typeof TASK_TYPES)[number];
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 🧩 PROMPT UNIT
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface PromptUnit {
  system: string;
  user: string;
}
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// ⚙️ TASK RUNTIME CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface TaskRuntimeConfig {
  aiConfigId: string;
  temperature: number;
  prompt: PromptUnit;
}
⋮----
// storage.local
export type TaskRuntimeConfigs = Record<TaskType, TaskRuntimeConfig>;
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 🤖 AGENT CONTEXT & RESPONSE (Single Source of Truth via Zod)
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export type AgentContext = z.infer<typeof AgentContextSchema>;
⋮----
export interface AgentResponse {
  ok: boolean;
  data?: string;
  error?: string;
}
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 🔧 AI CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface AIConfig {
  id: string;
  name: string;
  provider: string;
  model: string;
  isRemoteModel?: boolean;
  localModels: string[];
  remoteModels?: string[];
  apiKey: string;
  baseUrl: string;
  createdAt: number;
  updatedAt: number;
}
⋮----
// storage.local
export type AIConfigs = Record<string, AIConfig>;
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 🏃 TASK EXECUTORS
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface TaskExecutor {
  readonly taskType: TaskType;
  runtimeConfig: TaskRuntimeConfig;
  execute(context: AgentContext): Promise<string>;
}
⋮----
execute(context: AgentContext): Promise<string>;
⋮----
export interface TranslatorTaskExecutor extends TaskExecutor {
  readonly taskType: 'translate';
}
⋮----
export interface ExplainTaskExecutor extends TaskExecutor {
  readonly taskType: 'explain';
}
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 LANGUAGE AGENT SPECIFICATION
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface LangAgentSpec {
  readonly taskTypes: typeof TASK_TYPES;

  perform(taskType: TaskType, context: AgentContext): Promise<AgentResponse>;
}
⋮----
perform(taskType: TaskType, context: AgentContext): Promise<AgentResponse>;
⋮----
// ═══════════════════════════════════════════════════════════════════════════════
// 📊 EXECUTION RESULTS & HISTORY
// ═══════════════════════════════════════════════════════════════════════════════
⋮----
export interface AgentExecutionResult {
  id: string;

  timestamp: number;

  taskType: TaskType;

  context: AgentContext;

  result: string;

  aiConfigId: string;

  duration?: number;

  metadata?: {
    provider?: string;
    model?: string;
    temperature?: number;
    resultLength?: number;
  };
}
⋮----
// storage.local
export type AgentExecutionResults = AgentExecutionResult[];
</file>

<file path="src/assets/base.css">
@plugin "@tailwindcss/typography";
@plugin "daisyui" {
⋮----
@theme {
⋮----
/* Toast animations */
⋮----
* {
⋮----
.bb {
⋮----
.bb2 {
⋮----
/* Global transition animations */
.fade-enter-active,
⋮----
.fade-enter-from,
⋮----
.fade-enter-to,
⋮----
:host body {
</file>

<file path="src/assets/content-ui.css">
body {
</file>

<file path="src/assets/vue.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
</file>

<file path="src/components/AiConfig.vue">
<script setup lang="ts">
import { Eye, EyeOff, Minus, Plus, RefreshCcw, Trash } from 'lucide-vue-next';
import { storeToRefs } from 'pinia';
import { computed, ref, watch } from 'vue';

import type { AIConfig } from '@/agent/types';
import { useAiConfigsStore } from '@/stores/aiConfigs';
import { createLogger } from '@/utils/logger';
import { showToast } from '@/utils/toast';

interface ModelResponse {
  id: string;
  [key: string]: unknown;
}

const aiConfigsStore = useAiConfigsStore();

const { firstConfigId, lastActiveConfigId, aiConfigs } = storeToRefs(aiConfigsStore);

const configId = computed(() => String(lastActiveConfigId.value || firstConfigId.value));

const config = computed<AIConfig>(() => aiConfigs.value[configId.value]);

const logger = createLogger('AiConfig');

const newLocalModel = ref('');
const remoteModels = ref<string[]>([]);

// Initialize remoteModels with existing data from config
const initializeRemoteModels = () => {
  remoteModels.value = config.value.remoteModels ?? [];
};

// Watch for config changes and initialize remote models
watch(config, initializeRemoteModels, { immediate: true });

const showRemoteModels = ref(config.value.isRemoteModel ?? false);
const showApiKey = ref(false);

const addLocalModel = () => {
  if (!config.value) return;
  logger.debug`Adding local model: localModels=${config.value.localModels}`;
  const newModel = newLocalModel.value.trim();
  if (!newModel) return;
  config.value.localModels.push(newModel);
  config.value.model = newModel;
  newLocalModel.value = '';
};

const deleteLocalModel = () => {
  if (!config.value) return;
  config.value.localModels = config.value.localModels.filter(
    (model) => model !== config.value.model
  );
  config.value.model = config.value.localModels.at(-1) ?? '';
};

const deleteConfig = () => {
  aiConfigsStore.remove(configId.value);
};

const fetchModes = async () => {
  if (!config.value?.baseUrl) {
    showToast({
      message: 'No base URL found',
      type: 'error',
    });
    return;
  }

  const endpoint = `${config.value.baseUrl}/models`;

  logger.debug`Fetching models from ${endpoint}`;

  try {
    const response = await fetch(endpoint, {
      headers: {
        Authorization: `Bearer ${config.value.apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }

    const res = await response.json();

    if (!Array.isArray(res?.data)) {
      throw new Error('Invalid response format: "data" is not an array.');
    }

    const models = res.data.map((model: unknown) => {
      if (
        typeof model === 'object' &&
        model !== null &&
        'id' in model &&
        typeof (model as ModelResponse).id === 'string'
      ) {
        return (model as ModelResponse).id;
      }
      throw new Error('Invalid model format: missing or invalid id property');
    });

    remoteModels.value = models;

    // Persist remote models to the store
    if (config.value) {
      const updatedConfig = {
        ...config.value,
        remoteModels: models,
      };
      await aiConfigsStore.upsert(updatedConfig);
    }
  } catch (err) {
    logger.error`Failed to fetch models: ${err}`;
    showToast({
      message: `Error fetching models: ${err instanceof Error ? err.message : 'Unknown error'}`,
      type: 'error',
    });
    remoteModels.value = [];
  }
};

watch(showRemoteModels, (value) => {
  config.value.isRemoteModel = value;
});
</script>
<template>
  <div class="card card-lg px-16 shadow-xl">
    <div class="card-body flex flex-col">
      <h1 class="card-title mb-6 text-2xl font-bold">{{ config.name }}</h1>
      <div class="space-y-4">
        <!-- name -->
        <div class="form-control w-full">
          <label class="label" for="name">
            <span class="label-text font-medium">Config Name</span>
          </label>
          <input
            type="text"
            id="name"
            v-model="config.name"
            class="input input-bordered w-full"
            placeholder="Enter your name"
          />
        </div>
        <!-- Base URL -->
        <div class="form-control w-full">
          <label class="label" for="baseurl">
            <span class="label-text font-medium">Base URL</span>
          </label>
          <input
            type="url"
            id="baseurl"
            v-model="config.baseUrl"
            class="input input-bordered w-full"
            placeholder="https://api.example.com"
          />
        </div>

        <!-- API Key -->
        <div class="form-control w-full">
          <label class="label" for="apikey">
            <span class="label-text font-medium">API Key</span>
          </label>

          <div class="flex gap-2">
            <input
              :type="showApiKey ? 'text' : 'password'"
              id="apikey"
              v-model="config.apiKey"
              class="input input-bordered w-full"
              placeholder="Enter your API key"
            />
            <button class="btn btn-soft btn-primary w-fit" @click="showApiKey = !showApiKey">
              <EyeOff v-if="!showApiKey" class="h-4 w-4" />
              <Eye v-else class="h-4 w-4" />
            </button>
          </div>
        </div>

        <!-- Models -->
        <div class="form-control w-full">
          <fieldset class="fieldset flex flex-col gap-2">
            <legend class="label label-text flex gap-2 font-medium">
              Model

              <fieldset class="fieldset bg-base-100 border-base-300 rounded-box flex gap-2">
                <label class="label">
                  <input type="checkbox" v-model="showRemoteModels" class="checkbox checkbox-xs" />
                  Show remote models list
                </label>
              </fieldset>
            </legend>

            <div v-if="!showRemoteModels" class="join join-vertical gap-2">
              <div class="join-item flex items-center-safe gap-2">
                <select class="select" v-model="config.model">
                  <option v-if="config.localModels.length === 0" disabled selected>
                    Please add a custom model first
                  </option>
                  <option v-for="model in config.localModels" :key="model">
                    {{ model }}
                  </option>
                </select>

                <div class="tooltip" data-tip="Remove the model from list">
                  <button class="btn btn-soft w-fit" @click="deleteLocalModel">
                    <Minus />
                  </button>
                </div>
              </div>

              <!-- Add local model -->
              <div class="join-item flex gap-2">
                <input
                  type="text"
                  placeholder="Input a model id"
                  class="input"
                  v-model="newLocalModel"
                />

                <div class="tooltip" data-tip="Add a model to local list">
                  <button class="btn btn-soft btn-primary w-fit" @click="addLocalModel">
                    <Plus />
                  </button>
                </div>
              </div>
            </div>

            <!-- Select remote model -->
            <div class="flex gap-2" v-if="showRemoteModels">
              <select class="select" v-model="config.model">
                <option v-if="remoteModels.length === 0" disabled selected>
                  Please fetch models first
                </option>
                <option v-for="model in remoteModels" :key="model">
                  {{ model }}
                </option>
              </select>

              <button type="button" class="btn btn-soft btn-primary w-fit" @click="fetchModes">
                <RefreshCcw class="h-4 w-4" />
              </button>
            </div>
          </fieldset>
        </div>
      </div>
      <div class="mt-4 flex justify-end">
        <button class="btn btn-soft btn-error w-fit" @click="deleteConfig">
          <div class="tooltip" data-tip="Delete the config">
            <Trash />
          </div>
        </button>
      </div>
    </div>
  </div>
</template>
⋮----
<h1 class="card-title mb-6 text-2xl font-bold">{{ config.name }}</h1>
⋮----
<!-- name -->
⋮----
<!-- Base URL -->
⋮----
<!-- API Key -->
⋮----
<!-- Models -->
⋮----
{{ model }}
⋮----
<!-- Add local model -->
⋮----
<!-- Select remote model -->
⋮----
{{ model }}
</file>

<file path="src/components/HelloWorld.vue">
<script lang="ts" setup>
import { ref } from 'vue';

defineProps({
  msg: String,
});

const count = ref(0);
</script>
⋮----
<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Install
    <a href="https://github.com/vuejs/language-tools" target="_blank">Volar</a>
    in your IDE for a better DX
  </p>
  <p class="read-the-docs">Click on the WXT and Vue logos to learn more</p>
</template>
⋮----
<h1>{{ msg }}</h1>
⋮----
<button type="button" @click="count++">count is {{ count }}</button>
⋮----
<style scoped>
.read-the-docs {
  color: #888;
}
</style>
</file>

<file path="src/components/ParaCard.vue">
<script setup lang="ts">
import { CircleAlert } from 'lucide-vue-next';
import { ref } from 'vue';

import { createLogger } from '@/utils/logger';

export interface ParaCardProps {
  sourceText?: string;
  loading?: boolean;
  result?: string;
  error?: string;
}

const props = withDefaults(defineProps<ParaCardProps>(), {
  loading: false,
});

const logger = createLogger('ParaCard');
const isTab = ref('translation');
</script>
⋮----
<template>
  <div class="card prose-sm max-w-full rounded-md text-sm/relaxed">
    <div class="card-body p-3">
      <div v-if="props.loading" class="flex items-center gap-2">
        <span class="loading loading-spinner loading-sm"></span>
        <span class="text-base-content/70">Loading...</span>
      </div>

      <div v-else-if="props.error" class="alert alert-error">
        <CircleAlert />
        <span>{{ props.error }}</span>
      </div>

      <div v-else>
        {{ props.result }}
      </div>
    </div>
  </div>
</template>
⋮----
<span>{{ props.error }}</span>
⋮----
{{ props.result }}
</file>

<file path="src/components/PromptEditor.vue">
<script setup lang="ts">
import { computed, isProxy, ref, watch } from 'vue';
import VueJsonPretty from 'vue-json-pretty';

import type { TaskType } from '@/agent/types';
import { useTaskConfigsStore } from '@/stores/taskConfigs';
import { createLogger } from '@/utils/logger';

import 'vue-json-pretty/lib/styles.css';

import { isJSON } from 'es-toolkit';
import { storeToRefs } from 'pinia';

const logger = createLogger('PromptEditor');
const taskConfigsStore = useTaskConfigsStore();
const props = defineProps<{
  taskType: TaskType;
}>();

const { taskRuntimeConfigs } = storeToRefs(taskConfigsStore);

const runtimeConfig = computed(() => taskRuntimeConfigs.value[props.taskType]);

const prompt = computed(() => runtimeConfig.value.prompt);

const objPrompts = computed(() => ({
  system: isJSON(prompt.value.system) ? JSON.parse(prompt.value.system) : prompt.value.system,
  user: isJSON(prompt.value.user) ? JSON.parse(prompt.value.user) : prompt.value.user,
}));

const isPrettyMode = ref({
  system: true,
  user: true,
});
</script>
⋮----
<template>
  <div class="space-y-4">
    <div class="card bg-base-100 shadow-xl">
      <div class="card-body p-0">
        <div class="flex items-center justify-between">
          <label class="label">System Prompt</label>
          <fieldset class="fieldset bg-base-100 border-base-300 rounded-box border">
            <label class="label">
              Edit
              <input type="checkbox" class="toggle" v-model="isPrettyMode.system" />
              View
            </label>
          </fieldset>
        </div>

        <!-- <JsonTable v-if="isJsonMode" :data="JSON.parse(system)" /> -->

        <div v-if="isPrettyMode.system" class="json-view">
          <vue-json-pretty
            :data="objPrompts.system"
            :theme="'dark'"
            class="max-h-80 overflow-y-auto"
          />
        </div>
        <textarea
          v-else
          v-model="prompt.system"
          class="textarea textarea-bordered textarea-primary h-40 w-full"
        />
      </div>
    </div>

    <div class="card bg-base-100 shadow-xl">
      <div class="card-body p-0">
        <div class="flex items-center justify-between">
          <label class="label">User Prompt</label>
          <fieldset class="fieldset bg-base-100 border-base-300 rounded-box border">
            <label class="label">
              Edit
              <input type="checkbox" class="toggle" v-model="isPrettyMode.user" />
              View
            </label>
          </fieldset>
        </div>
        <!-- <JsonTable v-if="isJsonMode" :data="JSON.parse(user)" /> -->
        <div v-if="isPrettyMode.user" class="json-view">
          <vue-json-pretty
            :data="objPrompts.user"
            :theme="'dark'"
            class="max-h-80 overflow-y-auto"
          />
        </div>
        <textarea
          v-else
          v-model="prompt.user"
          class="textarea textarea-bordered textarea-primary h-40 w-full"
        />
      </div>
    </div>
  </div>
</template>
⋮----
<!-- <JsonTable v-if="isJsonMode" :data="JSON.parse(system)" /> -->
⋮----
<!-- <JsonTable v-if="isJsonMode" :data="JSON.parse(user)" /> -->
</file>

<file path="src/components/TaskConfig.vue">
<script setup lang="ts">
import { computed } from 'vue';

import type { TaskRuntimeConfig } from '@/agent/types';
import PromptEditor from '@/components/PromptEditor.vue';
import { useAiConfigsStore } from '@/stores/aiConfigs';
import { useTaskConfigsStore } from '@/stores/taskConfigs';
import { createLogger } from '@/utils/logger';

const logger = createLogger('TaskConfig');
const taskConfigsStore = useTaskConfigsStore();
const aiConfigsStore = useAiConfigsStore();

const { taskRuntimeConfigs } = taskConfigsStore;
const { aiConfigs } = aiConfigsStore;

const activeTaskId = computed(() => taskConfigsStore.lastActiveTaskId);

const runtimeConfig = computed<TaskRuntimeConfig>(() => taskRuntimeConfigs[activeTaskId.value]);
</script>
⋮----
<template>
  <div class="card shadow-xl">
    <fieldset class="fieldset card-body space-y-4">
      <legend class="fieldset-legend text-lg font-semibold">
        {{ activeTaskId.charAt(0).toUpperCase() + activeTaskId.slice(1) }} Task
      </legend>

      <div class="join join-horizontal justify-between">
        <label class="label join-item" for="aiConfigId">
          <span class="label-text font-semibold">Select AI Config</span>
        </label>
        <select class="select join-item" id="aiConfigId" v-model="runtimeConfig.aiConfigId">
          <option disabled selected>Pick an AI Config</option>
          <option v-for="config in aiConfigs" :key="config.id" :value="config.id">
            {{ config.name }}
          </option>
        </select>
      </div>

      <PromptEditor :taskType="activeTaskId" />

      <label class="label" for="temperature">
        <span class="label-text font-semibold">Temperature</span>
        <span class="label-text-alt text-base-content/70">{{
          runtimeConfig.temperature || 0
        }}</span>
      </label>

      <input
        id="temperature"
        type="range"
        min="0"
        max="2"
        step="0.1"
        v-model.number="runtimeConfig.temperature"
        class="range range-primary w-full"
      />
      <div class="text-base-content/60 mt-1 flex justify-between px-1 text-xs">
        <span>0</span>
        <span>1</span>
        <span>2</span>
      </div>
    </fieldset>
  </div>
</template>
⋮----
{{ activeTaskId.charAt(0).toUpperCase() + activeTaskId.slice(1) }} Task
⋮----
{{ config.name }}
⋮----
<span class="label-text-alt text-base-content/70">{{
          runtimeConfig.temperature || 0
        }}</span>
</file>

<file path="src/entrypoints/background.ts">
import { defineBackground } from '#imports';
⋮----
import { onMessage } from '@/messaging';
import { handleAgent } from '@/messaging/handlers';
import { createLogger } from '@/utils/logger';
⋮----
// Register message handlers
</file>

<file path="src/entrypoints/content/cache-manager.ts">
import Defuddle from 'defuddle';
⋮----
/**
 * Cached Defuddle instance to avoid re-parsing document on every translation.
 */
⋮----
/**
 * Cached document metadata containing title and description.
 */
⋮----
/**
 * Gets cached document metadata, creating it if not exists.
 *
 * @returns Document metadata containing title and description
 */
export const getDocumentMeta = ():
</file>

<file path="src/entrypoints/content/card-manager.ts">
import type { ContentScriptContext, ShadowRootContentScriptUi } from '#imports';
⋮----
import type { App } from 'vue';
⋮----
import type { AgentContext } from '@/agent/types';
import type { ParaCardProps } from '@/components/ParaCard.vue';
import { getDocumentMeta } from '@/entrypoints/content/cache-manager';
import { isEditable } from '@/entrypoints/content/content-utils';
import { addParaCard } from '@/entrypoints/content/ui-manager';
import { sendMessage } from '@/messaging';
import { createLogger } from '@/utils/logger';
import { extractReadableText, findClosestTextContainer, isParagraphLike } from '@/utils/paragraph';
⋮----
/**
 * Active cards indexed by a stable paragraph key. Each entry stores:
 * - `ui`: the ShadowRoot UI handle
 * - `container`: the host element
 * - `state`: the reactive ParaCard props to mutate as results arrive
 */
⋮----
/**
 * Removes a translation card and cleans its associated resources safely.
 *
 * @param paraKey - Unique identifier for the paragraph/card.
 * @param removeUI - When true (default), also detach and unmount the UI.
 *
 * @remarks
 * - Idempotent: safe to call multiple times; exits if nothing to clean.
 * - Also clears `data-para-*` flags from the host container.
 */
export const cleanupParaCard = (paraKey: string, removeUI = true) =>
⋮----
/**
 * If the current hover target is a paragraph-like container, toggles
 * a translation card in place:
 * - If a card exists for that paragraph, it is removed.
 * - If not, a loading card is added and an async translation is requested.
 *
 * @param ctx - Content script context from WXT
 * @param currentHoveredElement - The currently hovered element
 *
 * @remarks
 * - Guards against stale async results by checking `cardUIs` before applying updates.
 * - Stores the paragraph key in `data-para-id` to keep toggling stable.
 */
export const toggleParaCard = async (
  ctx: ContentScriptContext,
  currentHoveredElement: HTMLElement | null
) =>
⋮----
// Stable paragraph key (persisted on the container once created)
⋮----
// Set paraId immediately to prevent duplicate cards on quick toggles
⋮----
// Toggle behavior: remove if exists, otherwise create and load
⋮----
// 1) Create/loading UI
⋮----
// 2) Request translation/explanation from the agent
⋮----
// Ignore late results if the card was removed
⋮----
// Persist identity on the container for stable toggling
⋮----
// Ensure UI exits loading and shows error
⋮----
// UI may not exist yet, skip removing
⋮----
// Clean up stale attributes even if cardUIs doesn't have an entry
</file>

<file path="src/entrypoints/content/content-utils.ts">
/**
 * Checks if an element is editable (input, textarea, or contenteditable).
 * Moved outside toggleTranslateIfEligible to avoid recreation on each call.
 *
 * @param element - The element to check
 * @returns True if the element is editable
 */
export const isEditable = (element: Element | null): boolean =>
</file>

<file path="src/entrypoints/content/event-handler.ts">
import type { ContentScriptContext } from '#imports';
⋮----
import { throttle } from 'es-toolkit';
⋮----
import { toggleParaCard } from '@/entrypoints/content/card-manager';
import { findClosestTextContainer } from '@/utils/paragraph';
⋮----
/**
 * Currently hovered element (used to find its closest text container).
 * Cleared when the pointer leaves the paragraph region.
 */
⋮----
// Stable runner initialized in setupEventListeners
⋮----
/**
 * Tracks the hovered element if it belongs to a paragraph-like container.
 * Lightweight gate to avoid expensive work for non-paragraph nodes.
 * Expensive DOM operations are deferred until translation trigger.
 *
 * @param ev - Mouse event bubbling from the document.
 */
export const handleMouseOver = (ev: MouseEvent) =>
⋮----
// logger.debug`hovering over paragraph-like element`;
⋮----
/**
 * Clears the `currentHoveredElement` when leaving the paragraph region.
 * Prevents accidental toggles outside of the intended text block.
 *
 * @param ev - Mouse event bubbling from the document.
 */
export const handleMouseOut = (ev: MouseEvent) =>
⋮----
// logger.debug`left paragraph area`;
⋮----
/**
 * Handles keyboard events for translation triggering.
 *
 * @param ev - Keyboard event
 */
export const handleKeyDown = (ev: KeyboardEvent) =>
⋮----
/**
 * Sets up event listeners for the content script.
 *
 * @param ctx - Content script context from WXT
 * @returns Teardown function to remove event listeners
 */
export const setupEventListeners = (ctx: ContentScriptContext) =>
⋮----
// Prepare the throttled action once
⋮----
// --- Event subscriptions (passive for perf) ---
⋮----
const keydownHandler = (ev: KeyboardEvent)
⋮----
// Return teardown to avoid leaks
</file>

<file path="src/entrypoints/content/index.ts">
import { defineContentScript } from '#imports';
⋮----
import { setupEventListeners } from '@/entrypoints/content/event-handler';
import { createLogger } from '@/utils/logger';
⋮----
main(ctx)
⋮----
// Setup event listeners for hover and keyboard interactions
⋮----
// Store teardown for potential cleanup
</file>

<file path="src/entrypoints/content/ui-manager.ts">
import {
  createShadowRootUi,
  type ContentScriptContext,
  type ShadowRootContentScriptUi,
} from '#imports';
⋮----
import { createApp, h, shallowReactive, type App } from 'vue';
⋮----
import ParaCard, { type ParaCardProps } from '@/components/ParaCard.vue';
import { createLogger } from '@/utils/logger';
⋮----
/**
 * Associates each UI handle with its Vue `App` instance, enabling
 * proper unmount during cleanup. Uses WeakMap so GC can reclaim entries.
 */
⋮----
/**
 * Factory that creates a Vue app instance rendering a `ParaCard`.
 * Uses the provided reactive `state` so external code can update the card
 * (e.g., finish loading, set result, or set error).
 *
 * @param state - Reactive state passed as props to `ParaCard`.
 * @returns The mounted (yet not attached) Vue `App` instance.
 */
export const createParaCardApp = (state: ParaCardProps): App
⋮----
setup()
⋮----
/**
 * Creates and mounts a ParaCard UI next to a text container.
 * The UI is rendered inside a ShadowRoot to isolate styles and uses a dark theme.
 *
 * @param ctx - Content script context from WXT
 * @param container - Element that visually anchors the card inline.
 * @param initial - Optional initial state (e.g., `sourceText`, `loading`).
 * @returns A tuple with the mounted UI handle and the reactive state used by the card.
 *
 * @remarks
 * - The returned `state` object is meant to be mutated by the caller.
 * - The UI is mounted immediately; cleanup is handled elsewhere.
 */
export const addParaCard = async (
  ctx: ContentScriptContext,
  container: Element,
  initial: Partial<ParaCardProps> = {}
) =>
⋮----
// Track the Vue app for later unmount on removal
⋮----
// Clean up the app reference from the map
</file>

<file path="src/entrypoints/options/App.vue">
<script setup lang="ts">
import { browser } from '#imports';

import { Bolt, Wrench } from 'lucide-vue-next';
import { RouterLink, RouterView } from 'vue-router';

import { createLogger } from '@/utils/logger';
import { showToast, testToast } from '@/utils/toast';

const logger = createLogger('options');

const runToastTest = () => {
  testToast();
};

const resetStorage = () => {
  browser.storage.local
    .clear()
    .then(() => {
      showToast({
        message: 'Storage reset',
        type: 'success',
        position: 'toast-bottom toast-center',
      });
      return;
    })
    .catch((err) => {
      logger.error`Failed to reset storage: ${err}`;
      showToast({
        message: 'Failed to reset storage',
        type: 'error',
        position: 'toast-bottom toast-center',
      });
    });
};

const openDrawer = () => {
  document.getElementById('my-drawer')?.click();
};
</script>
⋮----
<template>
  <div class="mx-auto flex w-fit flex-col items-center font-sans">
    <div class="navbar flex h-4 max-h-[22vh] w-5xl justify-between">
      <h1 class="text-xl font-bold">Options</h1>

      <div class="drawer">
        <input id="my-drawer" type="checkbox" class="drawer-toggle" />
        <div class="drawer-content">
          <!-- Page content here -->
          <label for="my-drawer" class="btn btn-primary drawer-button hidden">Open drawer</label>
        </div>
        <div class="drawer-side">
          <label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label>
          <ul class="menu bg-base-200 text-base-content min-h-full w-80 p-4">
            <!-- Sidebar content here -->
            <li><button @click="runToastTest">Test Toast</button></li>
            <li><button @click="resetStorage">Reset Storage</button></li>
          </ul>
        </div>
      </div>

      <div class="fab inset-x-14 inset-y-8">
        <!-- a focusable div with tabindex is necessary to work on all browsers. role="button" is necessary for accessibility -->
        <div tabindex="0" role="button" class="btn btn-lg btn-circle btn-soft">
          <Bolt />
        </div>

        <!-- buttons that show up when FAB is open -->
        <div class="tooltip" data-tip="Debug Menu">
          <button class="btn btn-lg btn-circle" @click="openDrawer"><Wrench /></button>
        </div>
      </div>

      <div class="flex gap-2">
        <RouterLink :to="{ name: 'ai.config' }" class="btn btn-soft"> AI</RouterLink>
        <RouterLink :to="{ name: 'tasks.detail' }" class="btn btn-soft">Tasks</RouterLink>
        <RouterLink :to="{ name: 'history' }" class="btn btn-soft">History</RouterLink>
      </div>
    </div>

    <div class="divider mt-0"></div>

    <div class="min-h-[80dvh] w-3xl">
      <RouterView v-slot="{ Component, route }">
        <transition :name="(route.meta?.transition as string) || 'fade'" mode="out-in">
          <component :is="Component" :key="route.matched[0]?.path" />
        </transition>
      </RouterView>
    </div>

    <div class="divider"></div>
  </div>
</template>
⋮----
<!-- Page content here -->
⋮----
<!-- Sidebar content here -->
⋮----
<!-- a focusable div with tabindex is necessary to work on all browsers. role="button" is necessary for accessibility -->
⋮----
<!-- buttons that show up when FAB is open -->
</file>

<file path="src/entrypoints/options/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0" />
    <!-- Customize the manifest options -->
    <meta name="manifest.open_in_tab" content="true" />
    <meta
      name="description"
      content="Configure AI services and task settings for Para-Translator extension"
    />
    <title>Para-Translator Settings</title>

    <link
      rel="preload"
      href="/fonts/inter-latin-wght-normal.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="/fonts/inter-latin-ext-wght-normal.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />

    <link rel="stylesheet" href="@/assets/base.css" />
    <style>
      /*
        This inline style block is a performance optimization based on the principles from:
        https://www.jonoalderson.com/conjecture/youre-loading-fonts-wrong/

        1.  **Inlining @font-face**: Avoids a network request to discover the font files.
        2.  **Fallback Font with Metric Overrides**: An `@font-face` rule creates an 'Inter Fallback'
            using a common local font (Arial). Its metrics (`size-adjust`, `ascent-override`, etc.)
            are tuned to closely match the web font's (Inter Variable) metrics. This makes the swap
            from the fallback to the loaded web font much less jarring, significantly reducing CLS.
        3.  **Preloading**: The `<link rel="preload">` tag (added separately) for the `.woff2` file
            tells the browser to start fetching the font file earlier in the rendering process.

        By the time the main CSS loads, the font is likely already fetched and the fallback is
        correctly sized, leading to a smoother rendering experience.
      */
      @font-face {
        font-family: 'Inter Fallback';
        src: local('Arial');
        ascent-override: 90.79%;
        descent-override: 22.48%;
        line-gap-override: 0%;
        size-adjust: 107.28%;
      }

      /*
        The `@fontsource` package provides multiple files for different unicode ranges.
        We are inlining the 'latin' and 'latin-ext' subsets here, as they cover most
        use cases for this extension's audience. This follows the principle of shipping
        only the necessary glyphs. The font-display is set to 'swap'.
      */
      /* inter-latin-ext-wght-normal */
      @font-face {
        font-family: 'Inter Variable';
        font-style: normal;
        font-display: swap;
        font-weight: 100 900;
        src: url(/fonts/inter-latin-ext-wght-normal.woff2) format('woff2-variations');
        unicode-range:
          U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329,
          U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113,
          U+2C60-2C7F, U+A720-A7FF;
      }
      /* inter-latin-wght-normal */
      @font-face {
        font-family: 'Inter Variable';
        font-style: normal;
        font-display: swap;
        font-weight: 100 900;
        src: url(/fonts/inter-latin-wght-normal.woff2) format('woff2-variations');
        unicode-range:
          U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308,
          U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="./main.ts"></script>
  </body>
</html>
</file>

<file path="src/entrypoints/options/main.ts">
import { createPinia } from 'pinia';
import { createApp } from 'vue';
⋮----
import { useAiConfigsStore } from '@/stores/aiConfigs';
import { useTaskConfigsStore } from '@/stores/taskConfigs';
⋮----
import App from './App.vue';
import router from './router';
⋮----
// Preload stores before mounting to ensure route decisions have data available
const initializeStores = async () =>
</file>

<file path="src/entrypoints/options/router.ts">
import { createRouter, createWebHashHistory } from 'vue-router';
⋮----
import AiPanel from '@/entrypoints/options/views/AiPanel.vue';
import AiView from '@/entrypoints/options/views/AiView.vue';
import HistoryView from '@/entrypoints/options/views/HistoryView.vue';
import TaskPanel from '@/entrypoints/options/views/TaskPanel.vue';
import TaskView from '@/entrypoints/options/views/TaskView.vue';
⋮----
{ path: ':taskId?', name: 'tasks.detail', component: TaskPanel }, // for now, taskId === taskType
</file>

<file path="src/entrypoints/options/views/AiPanel.vue">
<script setup lang="ts">
import AiConfig from '@/components/AiConfig.vue';
</script>
⋮----
<template>
  <div>
    <div>
      <AiConfig />
    </div>
  </div>
</template>
</file>

<file path="src/entrypoints/options/views/AiView.vue">
<script setup lang="ts">
import { storeToRefs } from 'pinia';
import { computed, nextTick, ref, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';

import { useAiConfigsStore } from '@/stores/aiConfigs';

const route = useRoute();
const router = useRouter();
const aiConfigsStore = useAiConfigsStore();
const { aiConfigs, configIds, lastActiveConfigId, firstConfigId } = storeToRefs(aiConfigsStore);

// Template ref for the scrollable container
const scrollContainer = ref<HTMLElement>();

const activeConfigId = computed(() => {
  if (
    route.params.configId &&
    typeof route.params.configId === 'string' &&
    configIds.value.includes(route.params.configId)
  ) {
    return route.params.configId;
  }

  return lastActiveConfigId.value || firstConfigId.value;
});

// Function to scroll active config into view
const scrollToActiveConfig = async () => {
  if (!scrollContainer.value || !activeConfigId.value) return;

  await nextTick();

  // Find the active config element
  const activeElement = scrollContainer.value.querySelector(
    `[data-config-id="${activeConfigId.value}"]`
  ) as HTMLElement;

  if (activeElement) {
    // Scroll the element into view with smooth behavior
    activeElement.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'nearest',
    });

    // Programmatically focus the element for accessibility
    activeElement.focus({ preventScroll: true });
  }
};

const addNewConfig = async () => {
  const newConfigId = `new-${Date.now()}`;
  await aiConfigsStore.upsert({
    id: newConfigId,
    name: `New Config ${aiConfigsStore.configIds.length + 1}`,
    provider: 'new',
    model: 'new',
    localModels: [],
    apiKey: '',
    baseUrl: '',
    createdAt: Date.now(),
    updatedAt: Date.now(),
  });
  router.push({ name: 'ai.config', params: { configId: newConfigId } });
};

watch(
  () => route.params.configId,
  () => {
    scrollToActiveConfig();
  },
  { immediate: true }
);

watch(
  () => activeConfigId.value,
  (id) => {
    aiConfigsStore.setLastActiveConfigId(id);
    router.replace({ name: 'ai.config', params: { configId: id } });
  },
  { immediate: true }
);
</script>
⋮----
<template>
  <div class="flex items-start justify-center gap-9">
    <div class="navbar flex basis-1/4 flex-col items-start gap-2 self-start">
      <div>
        <button class="btn btn-soft btn-primary" @click="addNewConfig">+ New Config</button>
      </div>

      <div
        ref="scrollContainer"
        class="flex h-[68vh] flex-col items-start justify-start gap-2 overflow-y-auto pr-3"
      >
        <router-link
          v-for="configId in configIds"
          :key="configId"
          :data-config-id="configId"
          :to="{ name: 'ai.config', params: { configId } }"
          :class="['btn btn-soft w-36 text-sm focus:outline-0']"
          :title="aiConfigs[configId]?.name || String(configId)"
        >
          <p class="truncate">
            {{ aiConfigs[configId]?.name || configId }}
          </p>
        </router-link>
      </div>
    </div>
    <div class="flex-auto">
      <router-view v-slot="{ Component }">
        <keep-alive :max="10">
          <component :is="Component" :key="$route.params.configId" :config-id="activeConfigId" />
        </keep-alive>
      </router-view>
    </div>
  </div>
</template>
⋮----
{{ aiConfigs[configId]?.name || configId }}
</file>

<file path="src/entrypoints/options/views/HistoryView.vue">
<script setup lang="ts">
import { ref } from 'vue';

import { agentStorage } from '@/agent/storage';
import type { AgentExecutionResult } from '@/agent/types';
import ParaCard from '@/components/ParaCard.vue';
import { createLogger } from '@/utils/logger';

const logger = createLogger('HistoryView');
const history = ref<AgentExecutionResult[]>([]);

// option 1
agentStorage.agentExecutionResults
  .getValue()
  .then((value) => {
    history.value = value ?? [];
    return;
  })
  .catch((error) => {
    logger.error`Failed to get history, ${error}`;
  });
</script>
<template>
  <div class="container mx-auto max-w-6xl p-4">
    <!-- Header Section -->
    <div class="mb-6">
      <h1 class="text-base-content mb-2 text-3xl font-bold">Execution History</h1>
      <div class="text-base-content/70 flex items-center gap-4 text-sm">
        <span>Total Records: {{ history.length }}</span>
      </div>
    </div>

    <!-- Empty State -->
    <div v-if="history.length === 0" class="hero min-h-96">
      <div class="hero-content text-center">
        <div>
          <svg class="text-base-content/30 mb-4 h-16 w-16" fill="currentColor" viewBox="0 0 24 24">
            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h2 class="text-base-content mb-2 text-2xl font-bold">No Execution History</h2>
          <p class="text-base-content/70">
            Start using translation or explanation features to see your execution history here.
          </p>
        </div>
      </div>
    </div>

    <!-- History Grid -->
    <div v-else class="flex flex-col gap-4">
      <div
        v-for="item in history"
        :key="item.id"
        class="card bg-base-100 shadow-lg transition-shadow duration-200 hover:shadow-xl"
      >
        <div class="card-body p-5">
          <!-- Header Info -->
          <div class="mb-4 flex items-start justify-between">
            <div class="flex flex-col gap-1">
              <div class="flex items-center gap-2">
                <div v-if="item.duration" class="badge badge-outline badge-sm">
                  {{ Math.round(item.duration / 1000) }}s
                </div>
              </div>
              <div class="text-base-content/60 text-xs">
                <span class="ml-1">{{ new Date(item.timestamp).toLocaleString() }}</span>
              </div>
            </div>
            <div class="text-right">
              <div class="text-base-content/50 font-mono text-xs">{{ item.id.slice(-8) }}</div>
            </div>
          </div>

          <!-- Text Preview -->
          <div class="mb-3">
            <div class="text-base-content/80 bg-base-200 line-clamp-3 rounded-lg p-3 text-sm">
              {{ item.context.sourceText }}
            </div>
          </div>

          <!-- Metadata Tags -->
          <div class="mb-4 flex flex-wrap gap-2">
            <div v-if="item.metadata?.provider" class="badge badge-outline badge-xs">
              {{ item.metadata.provider }}
            </div>
            <div v-if="item.metadata?.model" class="badge badge-outline badge-xs">
              {{ item.metadata.model }}
            </div>
            <div v-if="item.metadata?.temperature" class="badge badge-ghost badge-xs">
              T: {{ item.metadata.temperature }}
            </div>
            <div v-if="item.metadata?.resultLength" class="badge badge-ghost badge-xs">
              {{ item.metadata.resultLength }} chars
            </div>
          </div>

          <!-- Collapsible Details -->
          <div class="collapse-arrow bg-base-200 collapse">
            <input type="checkbox" class="peer" />
            <div class="collapse-title peer-checked:bg-base-300 text-sm font-medium">
              View Details
            </div>
            <div class="collapse-content mt-2 space-y-3 text-sm">
              <div class="grid gap-2">
                <div class="flex justify-between">
                  <span class="font-medium">ID:</span>
                  <span class="font-mono text-xs">{{ item.id }}</span>
                </div>
                <div class="flex justify-between">
                  <span class="font-medium">AI Config:</span>
                  <span class="font-mono text-xs">{{ item.aiConfigId.slice(-8) }}</span>
                </div>
                <div v-if="item.context.siteTitle" class="flex justify-between">
                  <span class="font-medium">Page Title:</span>
                  <span class="text-xs">{{ item.context.siteTitle }}</span>
                </div>
                <div v-if="item.context.siteUrl" class="flex justify-between">
                  <span class="font-medium">Page URL:</span>
                  <a
                    :href="item.context.siteUrl"
                    target="_blank"
                    class="link link-primary text-xs"
                    >{{ item.context.siteUrl }}</a
                  >
                </div>
              </div>
              <div class="divider my-2"></div>
              <div>
                <div class="mb-2 font-medium">Result:</div>
                <div class="rounded p-3 text-sm">
                  <ParaCard :result="item.result" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer Stats -->
    <div v-if="history.length > 0" class="border-base-300 mt-8 border-t pt-6">
      <div class="stats stats-vertical lg:stats-horizontal w-full shadow">
        <div class="stat">
          <div class="stat-title">Total Executions</div>
          <div class="stat-value text-primary">{{ history.length }}</div>
        </div>
        <div class="stat">
          <div class="stat-title">Translations</div>
          <div class="stat-value text-secondary">
            {{ history.filter((item) => item.taskType === 'translate').length }}
          </div>
        </div>
        <div class="stat">
          <div class="stat-title">Explanations</div>
          <div class="stat-value text-accent">
            {{ history.filter((item) => item.taskType === 'explain').length }}
          </div>
        </div>
        <div class="stat">
          <div class="stat-title">Avg Duration</div>
          <div class="stat-value text-info">
            {{
              history.filter((item) => item.duration).length > 0
                ? Math.round(
                    history
                      .filter((item) => item.duration)
                      .reduce((sum, item) => sum + item.duration!, 0) /
                      history.filter((item) => item.duration).length /
                      1000
                  ) + 's'
                : 'N/A'
            }}
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
⋮----
<!-- Header Section -->
⋮----
<span>Total Records: {{ history.length }}</span>
⋮----
<!-- Empty State -->
⋮----
<!-- History Grid -->
⋮----
<!-- Header Info -->
⋮----
{{ Math.round(item.duration / 1000) }}s
⋮----
<span class="ml-1">{{ new Date(item.timestamp).toLocaleString() }}</span>
⋮----
<div class="text-base-content/50 font-mono text-xs">{{ item.id.slice(-8) }}</div>
⋮----
<!-- Text Preview -->
⋮----
{{ item.context.sourceText }}
⋮----
<!-- Metadata Tags -->
⋮----
{{ item.metadata.provider }}
⋮----
{{ item.metadata.model }}
⋮----
T: {{ item.metadata.temperature }}
⋮----
{{ item.metadata.resultLength }} chars
⋮----
<!-- Collapsible Details -->
⋮----
<span class="font-mono text-xs">{{ item.id }}</span>
⋮----
<span class="font-mono text-xs">{{ item.aiConfigId.slice(-8) }}</span>
⋮----
<span class="text-xs">{{ item.context.siteTitle }}</span>
⋮----
>{{ item.context.siteUrl }}</a
⋮----
<!-- Footer Stats -->
⋮----
<div class="stat-value text-primary">{{ history.length }}</div>
⋮----
{{ history.filter((item) => item.taskType === 'translate').length }}
⋮----
{{ history.filter((item) => item.taskType === 'explain').length }}
⋮----
{{
              history.filter((item) => item.duration).length > 0
                ? Math.round(
                    history
                      .filter((item) => item.duration)
                      .reduce((sum, item) => sum + item.duration!, 0) /
                      history.filter((item) => item.duration).length /
                      1000
                  ) + 's'
                : 'N/A'
            }}
</file>

<file path="src/entrypoints/options/views/TaskPanel.vue">
<script setup lang="ts">
import TaskConfig from '@/components/TaskConfig.vue';
</script>
⋮----
<template>
  <div>
    <div>
      <TaskConfig />
    </div>
  </div>
</template>
</file>

<file path="src/entrypoints/options/views/TaskView.vue">
<script setup lang="ts">
import { storeToRefs } from 'pinia';
import { computed, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';

import type { TaskType } from '@/agent/types';
import { useTaskConfigsStore } from '@/stores/taskConfigs';
import { createLogger } from '@/utils/logger';

const route = useRoute();
const router = useRouter();

const logger = createLogger('options');
const taskConfigsStore = useTaskConfigsStore();
const { taskIds, lastActiveTaskId, firstTaskId } = storeToRefs(taskConfigsStore);

const activeTaskId = computed(() => {
  if (route.params.taskId && typeof route.params.taskId === 'string') {
    return route.params.taskId as TaskType;
  }

  return lastActiveTaskId.value || (firstTaskId.value as TaskType);
});

watch(
  () => route.params.taskId,
  (newTaskId) => {
    if (!newTaskId || !taskIds.value.includes(String(newTaskId))) {
      const fallback = lastActiveTaskId.value || firstTaskId.value;
      if (fallback) {
        router.replace({
          name: 'tasks.detail',
          params: { taskId: fallback },
        });
      }
    }
  },
  { immediate: true }
);

watch(
  () => activeTaskId.value,
  (id) => {
    if (!id || !taskIds.value.includes(id)) {
      return;
    }
    taskConfigsStore.setLastActiveTaskId(id);

    router.replace({ name: 'tasks.detail', params: { taskId: id } });
  },
  { immediate: true }
);
</script>
⋮----
<template>
  <div>
    <div class="navbar flex gap-2">
      <router-link
        v-for="tid in taskIds.sort()"
        :key="tid"
        :to="{ name: 'tasks.detail', params: { taskId: tid } }"
        :class="['btn btn-soft']"
      >
        {{ String(tid).charAt(0).toUpperCase() + String(tid).slice(1) }}
      </router-link>
    </div>

    <div class="mt-2">
      <router-view v-slot="{ Component }">
        <keep-alive>
          <component :is="Component" :key="activeTaskId" />
        </keep-alive>
      </router-view>
    </div>
  </div>
</template>
⋮----
{{ String(tid).charAt(0).toUpperCase() + String(tid).slice(1) }}
</file>

<file path="src/entrypoints/popup/App.vue">
<script lang="ts" setup>
import HelloWorld from '@/components/HelloWorld.vue';
</script>
⋮----
<template>
  <div>
    <a href="https://wxt.dev" target="_blank">
      <img src="/wxt.svg" class="logo" alt="WXT logo" />
    </a>
    <a href="https://vuejs.org/" target="_blank">
      <img src="@/assets/vue.svg" class="logo vue" alt="Vue logo" />
    </a>
  </div>
  <HelloWorld msg="WXT + Vue" />
</template>
⋮----
<style scoped>
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #54bc4ae0);
}
.logo.vue:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
</style>
</file>

<file path="src/entrypoints/popup/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Default Popup Title</title>
    <meta name="manifest.type" content="browser_action" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="./main.ts"></script>
  </body>
</html>
</file>

<file path="src/entrypoints/popup/main.ts">
import { createApp } from 'vue';
⋮----
import App from './App.vue';
</file>

<file path="src/entrypoints/popup/style.css">
:root {
⋮----
a {
a:hover {
⋮----
body {
⋮----
h1 {
⋮----
button {
button:hover {
button:focus,
⋮----
.card {
⋮----
#app {
</file>

<file path="src/messaging/handlers.ts">
import { getLangAgent } from '@/agent/agent';
import type { AgentContext, AgentResponse, TaskType } from '@/agent/types';
⋮----
/**
 * Delegates a translation request to the background language agent and returns its response.
 *
 * @param context - Context for the translation operation (input text, target language, and related metadata).
 * @returns The agent's response for the translation operation.
 */
export async function handleAgent(data: {
  context: AgentContext;
  taskType: TaskType;
}): Promise<AgentResponse>
</file>

<file path="src/messaging/index.ts">
import { defineExtensionMessaging } from '@webext-core/messaging';
⋮----
import type { ProtocolMap } from './protocol';
⋮----
// Single source of truth for sendMessage/onMessage used across the extension
⋮----
// Bind methods to avoid unbound-method ESLint warnings
</file>

<file path="src/messaging/protocol.ts">
// Messaging protocol definitions for content <-> background
// comments: Define message types and their data/return contracts
⋮----
import type { AgentContext, AgentResponse, TaskType } from '@/agent/types';
⋮----
// Protocol map consumed by defineExtensionMessaging
export interface ProtocolMap {
  agent(data: { context: AgentContext; taskType: TaskType }): AgentResponse;
}
⋮----
agent(data:
</file>

<file path="src/stores/aiConfigs.ts">
import { isEqual, omit } from 'es-toolkit';
import { defineStore } from 'pinia';
import { computed, onScopeDispose, readonly, ref, toRaw, watch } from 'vue';
⋮----
import { AGENT_SEEDS } from '@/agent/seeds';
import { agentStorage } from '@/agent/storage';
import type { AIConfig, AIConfigs } from '@/agent/types';
import { createLogger } from '@/utils/logger';
⋮----
/**
   * Executes a function with write suppression, allowing for reentrant (nested) calls.
   * Uses a depth counter instead of a boolean flag to prevent premature clearing
   * when multiple nested operations are in progress.
   */
const withSuppressWrite = async <T>(fn: () => Promise<T> | T): Promise<T> =>
⋮----
// Getters
⋮----
// state -> storage
const writeToStorage = async () =>
⋮----
// Reload from storage to reconcile and expose error
⋮----
/**
   * Ensure the aiConfigs store is initialized.
   *
   * Loads initial AI configs from persistent storage into the in-memory map and sets up two-way synchronization:
   * - storage -> state: watches storage changes and merges them into the reactive `aiConfigsState` (last-write-wins by `updatedAt`).
   * - state -> storage: watches the in-memory state and writes changes back to storage (writes are suppressed during internal merges).
   *
   * This function is idempotent and concurrent-safe: if initialization is already complete it returns immediately; if an initialization
   * is in progress it returns the in-flight promise. On completion it marks the store as initialized and registers cleanup hooks
   * (unwatch functions) for the installed watchers.
   *
   * @returns A promise that resolves when initialization has completed.
   */
async function ensureInit(): Promise<void>
⋮----
// storage -> state (read)
⋮----
// Last-write-wins by updatedAt for each key
⋮----
// add/update
⋮----
// deletions (present locally but missing in storage)
⋮----
// treat as removed in storage
// no-op: simply don't copy it into `next`
⋮----
//  state -> storage (write)
⋮----
// Only allow writes when no suppression is active (depth === 0)
⋮----
/**
   * Ensure the aiConfigs store is initialized and synchronized with persistent storage.
   *
   * Awaits initialization (loading initial configs, setting up storage ↔ state watchers, and establishing suppression behavior).
   * Safe to call multiple times; returns immediately if initialization is already complete or in progress.
   */
async function load(): Promise<void>
⋮----
/**
   * Adds or updates an AI configuration in the store.
   *
   * Ensures the store is initialized, normalizes `localModels` and `remoteModels`, and merges the config into the in-memory `aiConfigsState`.
   * If an existing config with the same `id` exists and the only differences are `createdAt`/`updatedAt`, the update is skipped to avoid a no-op write.
   * When applied, `updatedAt` is set to the current timestamp and the config is merged into the state map.
   *
   * @param config - The AI configuration to add or update. Must include an `id`.
   * @returns A promise that resolves once the in-memory state has been updated.
   */
async function upsert(config: AIConfig): Promise<void>
⋮----
// Compare objects ignoring timestamp fields (createdAt and updatedAt)
⋮----
return; // Skip no-op write when objects are identical
⋮----
/**
   * Sets the last-active AI config ID if it exists in the current store.
   *
   * If `configId` is empty or does not match a key in the in-memory `aiConfigsState`,
   * no change is made (prevents dangling references).
   *
   * @param configId - The ID of the config to mark as last active.
   */
function setLastActiveConfigId(configId: string): void
⋮----
// Only accept ids that exist in current state to avoid dangling references
⋮----
/**
   * Remove an AI configuration from the in-memory store.
   *
   * Ensures the store is initialized, deletes the config with the given id from the reactive
   * aiConfigsState, and if the removed id was the lastActiveConfigId updates lastActiveConfigId
   * to the last remaining config id (or to an empty string when none remain).
   *
   * This function mutates only the in-memory state; persistence to storage is handled by the
   * store's state->storage synchronization watcher and is not performed directly here.
   */
async function remove(configId: string): Promise<void>
⋮----
// Register cleanup with onScopeDispose to avoid overriding Pinia's built-in $dispose
⋮----
// Reset initialization state to allow re-initialization if needed
</file>

<file path="src/stores/taskConfigs.ts">
import { defineStore } from 'pinia';
import { computed, onScopeDispose, ref, toRaw, watch } from 'vue';
⋮----
import { AGENT_SEEDS } from '@/agent/seeds';
import { agentStorage } from '@/agent/storage';
import type { TaskRuntimeConfig, TaskRuntimeConfigs, TaskType } from '@/agent/types';
import { createLogger } from '@/utils/logger';
⋮----
const suppressWriteDepth = ref(0); // Reentrant write suppression using depth counter
⋮----
// Getters to reduce repetitive computations in views
⋮----
/**
   * Executes a function with write suppression, allowing for reentrant (nested) calls.
   * Uses a depth counter instead of a boolean flag to prevent premature clearing
   * when multiple nested operations are in progress.
   */
const withSuppressWrite = async <T>(fn: () => Promise<T> | T): Promise<T> =>
⋮----
/**
   * Lazily initializes the task runtime configs from persistent storage and wires up bidirectional syncing.
   *
   * Loads task runtime configs from agentStorage (falling back to AGENT_SEEDS.TASK_RUNTIME_CONFIGS when absent),
   * establishes a storage watcher to merge external storage changes into the in-memory state (updates occur
   * inside a write-suppressed block), and establishes a Vue watcher to persist in-memory changes back to storage
   * (skipped while suppression is active). Initialization is deduplicated so concurrent callers share a single
   * in-flight initialization. Marks the store as initialized and sets up cleanup handles for the watchers.
   *
   * @returns A promise that resolves when initialization completes.
   */
async function ensureInit(): Promise<void>
⋮----
// Only allow writes when no suppression is active (depth === 0)
⋮----
async function load(): Promise<void>
⋮----
/**
   * Update and persist the runtime config for a single task type.
   *
   * Ensures the store is initialized, writes the provided config into persistent storage, and updates the in-memory configs. If the storage write fails, the error is recorded in `lastWriteError` and the in-memory configs are reloaded from storage (falling back to seeded defaults).
   *
   * @param taskType - The task type to update
   * @param config - The new runtime configuration for the task
   * @returns A promise that resolves when the update and in-memory synchronization complete
   */
async function updateOne(taskType: TaskType, config: TaskRuntimeConfig): Promise<void>
⋮----
// Reload from storage to reconcile
⋮----
function setLastActiveTaskId(taskId: TaskType): void
⋮----
// Only accept ids that exist in current state to avoid dangling references
⋮----
// Register cleanup with onScopeDispose to avoid overriding Pinia's built-in $dispose
⋮----
// Reset initialization state to allow re-initialization if needed
</file>

<file path="src/utils/__tests__/template.test.ts">
import { describe, expect, it } from 'vitest';
⋮----
import type { AgentContext } from '@/agent/types';
⋮----
import { renderTemplate } from '../template';
</file>

<file path="src/utils/logger.ts">
/*
 * style: prefer tagged template over normal function call
 */
⋮----
import {
  configureSync,
  defaultConsoleFormatter,
  getConsoleSink,
  getLogger,
} from '@logtape/logtape';
⋮----
export const createLogger = (...categoryParts: string[])
</file>

<file path="src/utils/paragraph.ts">
/**
 * Utilities for detecting and extracting paragraph-like text from DOM elements.
 * comments: Keep simple and focused for content-script use.
 */
⋮----
/**
 * Find the nearest ancestor paragraph-like HTMLElement for a given event target.
 *
 * If `target` is not a DOM Node, or no matching ancestor is found, returns `null`.
 *
 * @param target - The event target (may be an Element, a Node, or `null`)
 * @returns The closest ancestor matching paragraph-like selectors (e.g. `p`, `div`, `article`, etc.), or `null` if none
 */
export function findClosestTextContainer(target: EventTarget | null): HTMLElement | null
⋮----
/** Extract readable text from an element. Trims and normalizes whitespace. */
export function extractReadableText(el: HTMLElement | null): string
⋮----
/**
 * Heuristic check whether a string resembles a paragraph-sized text block.
 *
 * Returns false for empty or very short strings (less than 2 characters) and
 * for extremely long blocks (more than 5000 characters); otherwise returns true.
 *
 * @param text - The text to evaluate.
 * @returns `true` when `text` is non-empty and its length is between 2 and 5000 characters (inclusive of bounds checked by the function), otherwise `false`.
 */
export function isParagraphLike(text: string): boolean
⋮----
// Avoid extremely long blocks to reduce noise
</file>

<file path="src/utils/template.ts">
// src/utils/template.ts
⋮----
import { AGENT_CONTEXT_KEYS, type AgentContext } from '@/agent/types';
⋮----
/**
 * Built-in replacement keys for template rendering
 * Automatically extracted from AgentContext interface to maintain DRY principle
 */
⋮----
/**
 * Type for built-in replacement keys
 * Automatically inferred from AgentContext interface keys
 */
type BuiltinReplacementKey = keyof AgentContext;
⋮----
/**
 * Type for replacement mapper functions
 */
type ReplacementMapper = (context: AgentContext) => string;
⋮----
/**
 * Generic mapper function that handles both required and optional fields
 */
function createFieldMapper<K extends BuiltinReplacementKey>(key: K): ReplacementMapper
⋮----
return value ?? ''; // Handle both undefined and null cases
⋮----
/**
 * Built-in replacement mappers that extract values from context
 * Automatically generated from AgentContext keys to eliminate duplication
 */
⋮----
// Generate mappers for all builtin replacement keys
⋮----
/**
 * Render a template string with placeholders like `%{key}` using built-in replacements from context.
 * Performs a single pass with a global regex and uses a replacer callback
 * to avoid `$` interpolation issues in replacement strings.
 */
export function renderTemplate(template: string, context: AgentContext): string
⋮----
// Type-safe check for builtin replacement keys
⋮----
return mapper ? mapper(context) : match; // Keep original placeholder if key not found
</file>

<file path="src/utils/toast.ts">
/**
 * Toast notification utilities using daisyUI components.
 * Provides a simple API for displaying temporary notifications in the browser extension.
 */
⋮----
export type ToastType = 'success' | 'error' | 'warning' | 'info';
⋮----
export interface ToastOptions {
  /** The message to display in the toast */
  message: string;
  /** The type of toast which determines the visual style */
  type?: ToastType;
  /** How long the toast should be visible in milliseconds (default: 3000) */
  duration?: number;
  /** Position of the toast on screen (default: 'toast-bottom toast-end') */
  position?: string;
}
⋮----
/** The message to display in the toast */
⋮----
/** The type of toast which determines the visual style */
⋮----
/** How long the toast should be visible in milliseconds (default: 3000) */
⋮----
/** Position of the toast on screen (default: 'toast-bottom toast-end') */
⋮----
/**
 * CSS classes for different toast types
 */
⋮----
/**
 * Default toast options
 */
⋮----
/**
 * Show a toast notification
 *
 * @param options - Toast configuration options
 * @example
 * ```ts
 * showToast({
 *   message: 'Operation completed successfully!',
 *   type: 'success',
 *   duration: 5000,
 *   position: 'toast-center'
 * });
 * ```
 */
export function showToast(options: ToastOptions): void
⋮----
// Create toast container if it doesn't exist
⋮----
// Create toast element
⋮----
// Add to container
⋮----
// Auto remove after duration
⋮----
// Clean up container if empty
⋮----
/**
 * Debug function to test toast functionality
 */
export function testToast(): void
⋮----
// Test basic toast
⋮----
// Test success toast
⋮----
// Test error toast
</file>

</files>
